/*! \page page_quickstart Quick Start

\link docindex Documentation \endlink > QuickStart

\section Quick Quick Start 


In this basic quick start guide we will setup a virtual machine that sums two sinusoidal signals.
First we need to create a virtual machine:

~~~~~~~~~~~~~{.py}
from vafmcircuits import Machine

machine = Machine(name='machine', dt=0.01)
~~~~~~~~~~~~~

The first line imports the main \progname object, \link vafmcircuits.Machine Machine\endlink,
into the python console. The latter initialises a virtual machine with a timestep of 0.01, 
and stores it in a variable called <i>machine</i>. Having a reference to the machine is essential
to make it execute instructions.

We now add a wave generator to the setup:
~~~~~~~~~~~~~{.py}
machine.AddCircuit(type='waver', name='osc', freq=1.2, amp=1)
~~~~~~~~~~~~~
The \link vafmcircuits.Machine.AddCircuit AddCircuit\endlink function tells <i>machine</i> to insert
a new circuit of type \link vafmcircuits_signal_gens.waver waver\endlink in the scene. 
The newly created circuit will be called <i>osc</i>, which must be a unique identifier.
The \link vafmcircuits_signal_gens.waver waver\endlink circuit exposes the
<i>freq</i> and  <i>amp</i> input channels that are used to control the shape of the generated signal.
In this case, we are happy with constant frequency of 1.2 and amplitude of 1 (units are arbitrary),
so we append their values to the initialisation arguments.

In the same way, we create the \link vafmcircuits_math.opAdd opAdd\endlink circuit:
~~~~~~~~~~~~~{.py}
machine.AddCircuit(type='opAdd', name='adder', factors=2)
~~~~~~~~~~~~~
The <i>factors</i> argument determines how many input signals can be connected to <i>adder</i>,
to be summed out.

For the calculation to be performed, the input channels of <i>adder</i> must be connected to some
signals. In this case we want to sum the two waves generated by <i>osc</i>:
~~~~~~~~~~~~~{.py}
machine.Connect('osc.sin','adder.in1')
machine.Connect('osc.cos','adder.in2')
~~~~~~~~~~~~~
These two instructions connect the output <i>sin</i> and <i>cos</i> of circuit <i>osc</i> to the inputs
<i>in1</i> and <i>in2</i> of <i>adder</i> respectively.
Now, when the \link vafmcircuits_signal_gens.waver waver\endlink circuit is updated, the sine and cosine values
are fed to the \link vafmcircuits_math.opAdd opAdd\endlink, computing their sum.

If we want to be able to read <i>adder</i>'s output, for example in a file, we need an
\link vafmcircuits_output.output output\endlink circuit to print it:
~~~~~~~~~~~~~{.py}
logger = machine.AddCircuit(type='output', name='logger', file='tutorial_basic.out', dump=1)
logger.Register('global.time','osc.sin','osc.cos','adder.out')
~~~~~~~~~~~~~
The first line creates the \link vafmcircuits_output.output output\endlink circuit named <i>logger</i>,
and instructs it to print every <i>dump</i> frames in the file 'tutorial_basic.out'. In this case it will print every frame.
The second line tells <i>logger</i> which channels we want to print, 
through the \link vafmcircuits_output.output.Register Register\endlink function. Each channel is specified by
a "circuitname.channelname" string. 
Although there is no circuit called <i>global</i> in our setup, no error will be returned upon execution. 
The <i>global</i> circuit identifier refers to the circuit container in the current context, in this case
the main machine. The channel 'global.time' is always present in a virtual machine and contains the
simulation time.

Finally we issue a \link vafmcircuits.Machine.Wait Wait\endlink call:
~~~~~~~~~~~~~{.py}
machine.Wait(3)
~~~~~~~~~~~~~
The machine will integrate its circuits until 3 units of time are elapsed. Since the timestep was set to
0.01, the execution will perform 300 updates.

The full python input file is:
\include tutorial_basic.py


and the output is then plotted (gnuplot) as follows:

\htmlonly
<img src="quickstart.png" width="800px">
\endhtmlonly



*/
